<!DOCTYPE html>
<html>
  <head>
    <title>The Haskell Programming Language</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <script src="https://github.com/downloads/gnab/remark/remark-0.3.5.min.js" type="text/javascript"></script>
    <style type="text/css" media="screen">
      /* Slideshow styles */
    </style>
  </head>
  <body>
    <textarea id="source">

.center.middle
# The Haskell Programming Language
Part 1
(Based on Seven Languages in Seven Weeks)

---

# Agenda - part1

1. History
1. What is Haskell?
2. Basics
3. Functions
4. Recursion
5. Tuples
6. Lists
7. Ranges and Composition

---

# History
- _Haskell Brooks Curry_
 - His work in mathematical logic serves as a foundation for functional languages.
- A group from the Functional Programming Languages and Computer Architecture conference in 1987
 - open standard for a pure functional language
- Haskell was built to be a _pure_ functional programming languages
 - Special focus on lazy processing
- Haskell borned 1990
- current standard: Haskell 98

---
# What is Haskell?
- Functional
 - evaluating expressions
 - avoids using mutable state
 - first-class functions
- Strong Static typing 
- Implicitly typed
- Lazy processing 
- Lambda expressions

---
# Basics - Primitive types
### Numbers
    > 3 * 5
    15
    > 4 ^ 2 - 1
    15
    > (1 - 5)^(3 * 2 - 4)
    16


### Character Data
    > "hello"
    "hello"
    > "hello" ++ " world"
    "hello world"
    > ['h','i']
    "hi"

## Booleans
    > (4 + 5) == 9
    True
    > (5 + 5) /= 10    
    False

---
# Functions
- The centerpart of Haskell
- All functions takes only _one_ argument
- Can be defined in console: `let double x = x * 2`
- Defined in two parts:
 1. (optinal) type specification
 2. Implementation

Defined in `double.hs`:


     module Main where
      double :: Integer -> Integer
      double x = x * 2

---
# Functions, only one argument?
- What about adding two numbers?
- **Solution**: function currying 
 - `add e1 e2` is equivalent to `(add e1) e2`

### Add function:

    add :: Integer -> Integer -> Integer
    add x y = x + y


---
# Recursion
- Sum of all natrual numbers
- Pattern matching to end the recursive calls, haskell take the first match

      sum :: Integer -> Integer
      sum 0 = 0
      sum x = x + sum (x -1)

---
# Control structures
### If/then/else

`if <condition> then <true-value> else <false-value>`

- In Haskell _if_ is an expression (not a statement)
- else is required


    describeLetter :: Char -> String
    describeLetter c =
      if c >= 'a' && c <= 'z'
        then "Lower case"
        else if c >= 'A' && c <= 'Z'
          then "Upper case"
          else "Not an ASCII letter"

---
#  Control structures
### Guards
- Restricts the value of the arguments
- When a guard is satisfied Haskell calls the appropriate function


    describeLetter :: Char -> String
    describeLetter c
     | c >= 'a' && c <= 'z' = "Lower case"
     | c >= 'A' && c <= 'Z' = "Upper case"
     | otherwise            = "Not an ASCII letter"
    

Can replace pattern matching:

    sumG :: Integer -> Integer
    sumG x
      | x > 0 = x + sumG (x - 1)
      | otherwise = 0


---
# Tuples
- A collection of a *fixed* number of *items*
- Comma separated items in parantheses
- Example: `(1, "hello", True)`
- Can have tuples in tuples: '((0, 2), (1, 2), True)`

### Retrieving values:

    fst (1, 2)
    > 1

    //Definition
    fst :: (a, b) -> a
    fst (a,b) = a


---
# Lists
Collection of items of *same* type

    let numbers = [1,2,3,4] 
    let strings = ["hei", "hello", "Hola"]

(:) operator:

    let numbers = [1,2,3,4] 
    0:numbers
    > [0,1,2,3,4]
    
    0:4:numbers
    > [0,4,1,2,3,4]

---
# Traversing lists

    head [1,2,3]
    > 1

    tail [1,2,3]
    > [2,3]

    //binding list to (h:t)
    let (h:t) = [1,2,3]

Finding the size of a list:

    size [] = 0
    size (h:t) = 1 + size t


---
# Combining lists

- *zip* is a powerful way to combine lists
- combines nth elements of each of the lists
- great for storing information which is related to another bit of data


     zip ["ivar", "ole"] [20, 30]
     > [("ivar",20),("ole",30)]


### Candidate with highest score?

    maximum (zip ["ivar", "ole"] [20, 30])
    > ("ole", 30)

---
# Ranges

    [1..2] 
    > [1,2]
    
    [1..4] 
    > [1,2,3,4]
    
    [10, 8 .. 4] 
    > [10,8,6,4]

    //Can also work in fractional numbers
    [10, 9.5, .. 4] 


---
# Sequences

    take 3 [1 ..]
    > [1,2,3]

    take 3 [0, 2 ..]
    > [0,2,4]


---
# List Comprehension
kj


---
# Define and load Haskell source files

---
# Tasks part 1
1. Create a function that returns the third value in a tuple. 
 - E.g. `thr (1, 2, 3)` should return 3

2. Create function sumList used to calculate the sum of the values in a list
 - E.g `sumList [1,3,4]` should return 8

    </textarea>
    <div id="slideshow"></div>
  </body>
</html>
